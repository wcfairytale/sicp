#lang racket

;interval
(define (make_interval x y)
  (cons x y))
(define (lower_bound interval)
  (car interval))
(define (upper_bound interval)
  (cdr interval))

;helpers
(define (span_zero interval)
  (and (<= (lower_bound interval) 0)
       (>= (upper_bound interval) 0)))

(define (print_interval interval)
  (display "[")
  (display (lower_bound interval))
  (display ",")
  (display (upper_bound interval))
  (display "]"))

;arithmatics
(define (add_interval a b)
  (make_interval (+ (lower_bound a) (lower_bound b))
                 (+ (upper_bound a) (upper_bound b))))
(define (sub_interval a b)
  (add_interval a
                (make_interval (- upper_bound b)
                               (- lower_bound b))))

(define (mul_interval a b)
  (let ((p1 (* (lower_bound a) (lower_bound b)))
        (p2 (* (lower_bound a) (upper_bound b)))
        (p3 (* (upper_bound a) (lower_bound b)))
        (p4 (* (upper_bound a) (upper_bound b))))
    (make_interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
(define (div_interval a b)
  (if (span_zero b)
      (print "error divide by an interval that spans zero")
      (mul_interval a
                    (make_interval (/ 1.0 (upper_bound b))
                                   (/ 1.0 (lower_bound b))))))

(define (interval_width interval)
  (/ (- (upper_bound interval)
        (lower_bound interval))
     2))

;9-case mul
;{--, -+, ++} * (--, -+, ++}
(define (mul_interval_2 a b)
  (let ((la (lower_bound a))
        (ua (upper_bound a))
        (lb (lower_bound b))
        (ub (upper_bound b)))
    (cond ((and (< la 0) (< ua 0) (< lb 0) (< ub 0))
           (make_interval (* ua ub) (* la lb)))
          ((and (< la 0) (< ua 0) (< lb 0) (> ub 0))
           (make_interval (* la ub) (* la lb)))
          ((and (< la 0) (< ua 0) (> lb 0) (> ub 0))
           (make_interval (* la ub) (* ua lb)))
          ((and (< la 0) (> ua 0) (< lb 0) (< ub 0))
           (make_interval (* ua lb) (* la lb)))
          ((and (< la 0) (> ua 0) (< lb 0) (> ub 0))
           (make_interval (min (* la ub) (* ua lb)) (max (* la lb) (* ua ub))))
          ((and (< la 0) (> ua 0) (> lb 0) (> ub 0))
           (make_interval (* la ub) (* ua ub)))
          ((and (> la 0) (> ua 0) (< lb 0) (< ub 0))
           (make_interval (* ua lb) (* la ub)))
          ((and (> la 0) (> ua 0) (< lb 0) (> ub 0))
           (make_interval (* ua lb) (* ua ub)))
          ((and (> la 0) (> ua 0) (> lb 0) (> ub 0))
           (make_interval (* la lb) (* ua ub))))))

;unit test
(define interval_a_1 (make_interval -4 -1))
(define interval_a_2 (make_interval -1 4))
(define interval_a_3 (make_interval 1 4))

(define interval_b_1 (make_interval -3 -2))
(define interval_b_2 (make_interval -2 3))
(define interval_b_3 (make_interval 2 3))

(define (unit_test)
  (let ((case1 (mul_interval_2 interval_a_1 interval_b_1))
        (case2 (mul_interval_2 interval_a_1 interval_b_2))
        (case3 (mul_interval_2 interval_a_1 interval_b_3))
        (case4 (mul_interval_2 interval_a_2 interval_b_1))
        (case5 (mul_interval_2 interval_a_2 interval_b_2))
        (case6 (mul_interval_2 interval_a_2 interval_b_3))
        (case7 (mul_interval_2 interval_a_3 interval_b_1))
        (case8 (mul_interval_2 interval_a_3 interval_b_2))
        (case9 (mul_interval_2 interval_a_3 interval_b_3)))
    (cond ((not (and (= (lower_bound case1) 2) (= (upper_bound case1) 12))) (print "case1 wrong!"))
          ((not (and (= (lower_bound case2) -12) (= (upper_bound case2) 8))) (print "case2 wrong!"))
          ((not (and (= (lower_bound case3) -12) (= (upper_bound case3) -2))) (print "case3 wrong!"))
          ((not (and (= (lower_bound case4) -12) (= (upper_bound case4) 3))) (print "case4 wrong!"))
          ((not (and (= (lower_bound case5) -8) (= (upper_bound case5) 12))) (print "case5 wrong!"))
          ((not (and (= (lower_bound case6) -3) (= (upper_bound case6) 12))) (print "case6 wrong!"))
          ((not (and (= (lower_bound case7) -12) (= (upper_bound case7) -2))) (print "case7 wrong!"))
          ((not (and (= (lower_bound case8) -8) (= (upper_bound case8) 12))) (print "case8 wrong!"))
          ((not (and (= (lower_bound case9) 2) (= (upper_bound case9) 12))) (print "case9 wrong!"))
          (else (print "success!")))))